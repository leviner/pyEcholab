# coding=utf-8

#    National Oceanic and Atmospheric Administration
#    Alaskan Fisheries Science Center
#    Resource Assessment and Conservation Engineering
#    Midwater Assessment and Conservation Engineering

# THIS SOFTWARE AND ITS DOCUMENTATION ARE CONSIDERED TO BE IN THE PUBLIC DOMAIN
# AND THUS ARE AVAILABLE FOR UNRESTRICTED PUBLIC USE. THEY ARE FURNISHED "AS
# IS." THE AUTHORS, THE UNITED STATES GOVERNMENT, ITS INSTRUMENTALITIES,
# OFFICERS, EMPLOYEES, AND AGENTS MAKE NO WARRANTY, EXPRESS OR IMPLIED, AS TO
# THE USEFULNESS OF THE SOFTWARE AND DOCUMENTATION FOR ANY PURPOSE.  THEY
# ASSUME NO RESPONSIBILITY (1) FOR THE USE OF THE SOFTWARE AND DOCUMENTATION;
# OR (2) TO PROVIDE TECHNICAL SUPPORT TO USERS.

'''
.. module:: echolab2.instruments.echosounder

    :synopsis:  The top level interface for reading data files collected
                using scientific echosunders commonly used in fisheries
                stock assessment and research.

    The echosounder module provides a simplified interface for reading raw data
    generated by EK60, EK80, and similar instruments. Due to the wide variety of
    instruments that utilize the Simrad "raw" data format and their many configuration
    options, pyEcholab's classes for working with these data are complex. The
    echosounder module makes a few assumptions that are applicable to most use
    cases that significantly reduces this complexity. These assumptions are:

        All raw files passed to the read() function will have the same general
        file format (EK60 or EK80). If you pass a list of multiple files to
        read() where some are EK60 formatted and some are EK80, an error will
        be raised.

        All files passed to the read() function will contain the same data type.
        The data types are power only, angles only, power+angles, and complex.

    If you need to read different formats, or different data types you can read
    them separately and combine after they have been read and converted, or you
    can implement something more complex using the EK60 and/or EK80 objects
    directly.


| Developed by:  Rick Towler   <rick.towler@noaa.gov>
| National Oceanic and Atmospheric Administration (NOAA)
| Alaska Fisheries Science Center (AFSC)
| Midwater Assesment and Conservation Engineering Group (MACE)
|
| Authors:
|       Rick Towler   <rick.towler@noaa.gov>
| Maintained by:
|       Rick Towler   <rick.towler@noaa.gov>

$Id$
'''

import os
from . import EK80
from . import EK60
from .util import simrad_utils


SIMRAD_EK60 = 0
SIMRAD_EK80 = 1




def read(files, ignore_errors=False, **kwargs):
    """read reads one or more Simrad EK60 style *OR* EK80 style .raw echosounder
    data files and returns a EK60 or EK80 object containing the data. Supported
    systems are:

        Simrad EK60, ES60, ME70, ES70, EK80, ES80

    The simplified interface provided by the echosounder module assumes that
    all files will have the same format (EK60 or EK80) and that they will all
    contain the same basic data type (power only, angle only, power+angle, or
    complex.)

    If the bottom detection files are colocated with the .raw data, it will
    also attempt to read those files. These files must be located in the same
    directory as the .raw files and they must follow the standard Simrad naming
    convention. Supported formats include only .bot and .xyz files (default
    preference is for .xyz.) While the underlying classes support reading .out
    files, this simplified interface does not.

    """

    # if we're given a string, wrap it in a list
    if not isinstance(files, list):
            files = [files]

    #  initilaize s
    data_object = None

    # Work through the list of input files
    for index, item in enumerate(files):
        filename = os.path.normpath(item)

        # Determine what kind of data file we have
        data_type = _check_filetype(filename)
        if data_object is None:
            #  This is the first file we're reading so we need to create the data object
            if data_type == SIMRAD_EK60:
                # This is an EK60 file, we're going to assume all files are EK60
                data_object = EK60.EK60()
            elif data_type == SIMRAD_EK80:
                # This is an EK80 file, we're going to assume all files are EK80
                data_object = EK80.EK80()
            else:
                # We don't know what this is
                raise UnknownFormatError("Unknown file type encountered: " + filename)

        #  check to make sure all of the files share the same file format
        elif ((data_type == SIMRAD_EK60 and isinstance(data_object, EK80)) or
              (data_type == SIMRAD_EK80 and isinstance(data_object, EK60))):
            # We've encountered a file with a different type than the initial file read
                raise TypeError("Mixed Ex80 and Ex60 data files encountered. The echosounder " +
                        "module does not support reading mixed data file formats at one time. " +
                        "Either read these files in separate calls to echosounder.read() or " +
                        "implement your code using the underlying EK60 and EK80 classes.")

        # Read the data file using the object for this data type
        data_object.append_raw(filename, **kwargs)

        #  now try to read the bottom data. We are assuming the .bot or .XYZ files are colocated
        #  with the .raw file and that they follow the normal Simrad naming convention.
        if data_type == SIMRAD_EK80:
            #  Simrad EK80 systems can generate both XYZ and.or .bot files
            bot_type, bot_files = simrad_utils.get_simrad_bottom_files(filename, data_object)
            if type == 'BOT':
                data_object.read_bot(bot_files)
            elif type == 'XYZ':
                for channel_id in bot_files:
                    data_object.read_xyz(channel_id, bot_files[channel_id])

        elif data_type == SIMRAD_EK60:
            #  Simrad EK60 systems do not generate XYZ files so we only check for .bot files
            _, bot_files = simrad_utils.get_simrad_bottom_files(filename, data_object,
                skip_xyz=True)
            if bot_files:
                data_object.read_bot(bot_files)


    return data_object


def get_calibration_from_raw(data_object, **kwargs):
    '''get_calibration_from_raw returns a dictionary, keyed by channel ID,
    containing a calibration object populated with data extracted from the
    raw data contained in the provided data_object.

    If you want to use different calibration parameters than the ones in the
    raw data, you will want to call this function to get the initial calibration
    objects and then modify them as needed.

    Like all functions in the echosounder module, this function assumes that
    your data object contains only one type of data (power only, angle only,
    power+angle, or complex) and will return data from the first data type
    only.

    data_object (EK60 or EK80 object): Set this to an instance of the EK60 or
        EK80 object that you obtained after calling echosounder.read().

    absorption_method (str): Set this to a string specifying the method used
        for computing absorption. Available methods are:

        'A&M': Computes absorption using the equation describe in:

        Ainslie M. A., McColm J. G., "A simplified formula for viscous and
          chemical absorption in sea water", Journal of the Acoustical Society
          of America, 103(3), 1671-1672, 1998.

        'F&G': Computes absorption using the equation describe in:

        Francois R. E., Garrison G. R., "Sound absorption based on ocean
          measurements: Part II:Boric acid contribution and equation for
          total absorption", Journal of the Acoustical Society of America,
          72(6), 1879-1890, 1982.

        Default value is 'F&G'

    '''

    calibrations = {}

    for chan in data_object.raw_data:
        calibrations[chan] = data_object.raw_data[chan][0].get_calibration(**kwargs)

    return calibrations


def get_calibration_from_ecs(data_object, ecs_file, channel_map=None, **kwargs):
    '''get_calibration_from_ecs will returns a dictionary, keyed by channel ID,
    containing a calibration object populated with data extracted from an Echoview
    .ecs file. Calibration parameters not present or commented out in the .ecs file
    will be populated from the raw data contained in the provided data_object.


    Like all functions in the echosounder module, this function assumes that
    your data object contains only one type of data (power only, angle only,
    power+angle, or complex) and will return data from the first data type
    only.

    data_object (EK60 or EK80 object): Set this to an instance of the EK60 or
        EK80 object that you obtained after calling echosounder.read().

    ecs_file (str): Set this to the full path to the .ecs file you want to read.

    absorption_method (str): Set this to a string specifying the method used
        for computing absorption. Available methods are:

        'A&M': Computes absorption using the equation describe in:

        Ainslie M. A., McColm J. G., "A simplified formula for viscous and
          chemical absorption in sea water", Journal of the Acoustical Society
          of America, 103(3), 1671-1672, 1998.

        'F&G': Computes absorption using the equation describe in:

        Francois R. E., Garrison G. R., "Sound absorption based on ocean
          measurements: Part II:Boric acid contribution and equation for
          total absorption", Journal of the Acoustical Society of America,
          72(6), 1879-1890, 1982.

        Default value is 'F&G'

    '''

    calibrations = {}
    last_chan = None
    T = 1

    for chan in data_object.raw_data:
        calibrations[chan] = data_object.raw_data[chan][0].get_calibration(**kwargs)

        #  Generate the EV calibration label.
        #  First parse the channel ID for channel number
        chan_parts = chan.split('_')

        #  check if this is a new transceiver+transducer
        if last_chan is not None:
            if last_chan != chan:
                #  we have a new one, increment the counter
                T += 1
                last_chan = chan
        else:
            #  this is the first channel we have encountered
            last_chan = chan

        #  set the base label value
        ev_cal_label = "T%i" % (T)

        #  check if we need to add a channel number
        if len(chan_parts) > 1:
            #  yes, there is a channel number attached to the channel ID
            ev_cal_label += " (channel %s)" % (chan_parts[1])

        #  finally read the ecs file and update the params in our calibration
        ecs_file = os.path.normpath(ecs_file)
        calibrations[chan].read_ecs_file(ecs_file, ev_cal_label)


def get_Sv(data_object, calibration=None, frequencies=None,
        channels=None, heave_correct=False, **kwargs):
    '''get_Sv returns a dictionary, keyed by channel ID, containing
        aprocessed_data objects containing Sv or sv data.

        The frequencies and channels keywords can be set to limit what
        data is returned. These keywords can be applied together.

        frequencies (list): Set this to a list containing the frequencies to
            return data from.

            Default: None (return all frequencies)

        channels (list): Set this to a list containing the channel IDs to
            return data from.

            Default: None (return all channels)

        return_indices (np.array uint32): Set this to a numpy array that contains
            the index values to return in the processed data object. This can be
            used for more advanced anipulations where start/end ping/time are
            inadequate.

            Default: None (return all pings)

        calibration (EK80.ek80_calibration): Set to an instance of
            EK80.ek80_calibration containing the calibration parameters
            you want to use when transforming to Sv/sv. If no calibration
            object is provided, the values will be extracted from the raw
            data.

            Default: None

        linear (bool): Set to True if getting "sv" data

            Default: False

        tvg_correction (bool): Set to True to apply TVG range correction.
            Typically you want to leave this at True.

            Default: True

        return_depth (bool): Set to True to return a processed_data object
            with a depth axis. When False, the processed_data object has
            a range axis.

            Default: False

        heave_correct (bool): Set to True to return a processed_data object
            that has heave correction applied. Heave correction shifts samples
            vertically to compensate for the sounder platform's vertical motion.
            Heave corrected data is always returned as depth.

            Default: False

        start_time (datetime64): Set to a numpy datetime64 oject specifying
            the start time of the data to convert. All data between the start
            and end time will be returned. If set to None, the start time is
            the first ping.

            Default: None

        end_time (datetime64): Set to a numpy datetime64 oject specifying
            the end time of the data to convert. All data between the start
            and end time will be returned. If set to None, the end time is
            the last ping.

            Default: None

        start_ping (int): Set to an integer specifying the first ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the first ping is set as the start ping.

            Default: None

        end_ping (int): Set to an integer specifying the end ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the last ping is set as the end ping.

            Default: None
    '''

    data = {}

    #  iterate thru all of the channels
    for chan in data_object.raw_data:

        #  get a reference to this channel's raw data
        raw_obj = data_object.raw_data[chan][0]

        #  check if we're returning this channel
        return_chan = _filter_channel(chan, raw_obj, channels, frequencies)

        # if we are, get all of the data
        if return_chan:
            #  first, get a calibration object for this channel
            if calibration:
                if chan in calibration:
                    #  one is provided
                    cal_obj = calibration[chan]
                else:
                    #  cal dict provided but this channel not in it - get from raw
                    cal_obj = raw_obj.get_calibration(**kwargs)
            else:
                #  no cal provided - get one using the raw file parameters
                cal_obj = raw_obj.get_calibration(**kwargs)

            #  then get the data
            sv_data = raw_obj.get_Sv(calibration=cal_obj, **kwargs)

            #  add the navigation and motion data - this takes the asynchronous NMEA
            #  and motion data and interpolates it onto the ping time axis and stores
            #  the data in the processed data object.
            sv_data.set_navigation(data_object.nmea_data)
            sv_data.set_motion(data_object.motion_data)

            #  apply heave correction if needed - this has no effect if heave
            #  data is not available.
            if heave_correct:
                sv_data.heave_correct()

            #  get the bottom detection data. This method will automatically
            #  correct depths as needed if the calibration sound speed is different
            #  from the sound speed at the time of collection.
            bottom_line = raw_obj.get_bottom(calibration=cal_obj, **kwargs)

            #  Bottom data is always recorded as depth with heave correction applied,
            #  so we need to back out transducer Z offset and/or heave (if applicable)
            #  when returning sample data with range as the vertical axis
            v_axis = sv_data.get_v_axis()[1]
            if v_axis == 'range':
                #  the transducer_draft attribute of the bottom line contains both
                #  the z offset and heave. We simply subtract these values from the
                #  line data to get the line in range.
                bottom_line = bottom_line - bottom_line.transducer_draft
            else:
                #  we're returning data as depth. We don't need to back out transducer
                #  z offset, but we have to back out heave correction if the user has
                #  not heave corrected the sample data
                if not heave_correct:
                    #  heave correction is not set, subtract heave from the bottom line
                    bottom_line = bottom_line - sv_data.heave

            #  insert the bottom detection line into the processed data object
            sv_data.bottom = bottom_line

            #  and add the data to our return dict
            data[chan] = sv_data

    return data


def get_sv(data_object, linear=True, **kwargs):

    return get_Sv(data_object, linear=True, **kwargs)



def _filter_channel(chan, raw_obj, channels, frequencies):

    return_chan = False
    if channels is None and frequencies is None:
        return_chan = True
    elif channels is None and raw_obj.get_frequency() in frequencies:
        return_chan = True
    elif frequencies is None and chan in channels:
        return_chan = True
    elif raw_obj.get_frequency() in frequencies and chan in channels:
        return_chan = True

    return return_chan


def _check_filetype(filename):

    # Read in the file header, this value can change if additional
    # instruments are introduced with larger headers.
    fh = open(filename, "rb")
    header = fh.read(8)
    fh.close()

    # Return the file type based on the header
    if header[4:8]==b'CON0':
        # Simrad EK60 style raw files start  with 4 bytes for the size then C O N 0
        return SIMRAD_EK60

    elif header[4:8]==b'XML0':
        # Simrad EK80 style raw files start with 4 bytes for the size then X M L 0
        return SIMRAD_EK80

    else:
       return -1



class UnknownFormatError(Exception):
    pass
